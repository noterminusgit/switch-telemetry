# 09: Authentication & Security

## Overview

Switch Telemetry uses session-based authentication backed by a `user_tokens` database table, with Bcrypt password hashing and optional magic link (passwordless) login for admin-allowlisted emails. A three-tier RBAC model (admin / operator / viewer) controls what each user can do. Device credentials are encrypted at rest using Cloak (AES-256-GCM). Security headers (CSP, HSTS, CSRF) are enforced at the router and endpoint level.

All auth logic lives in three layers:

| Layer | Module | Responsibility |
|---|---|---|
| Context | `SwitchTelemetry.Accounts` | User CRUD, token lifecycle, magic link flow, admin promotion |
| Plugs & Hooks | `SwitchTelemetryWeb.UserAuth` | Conn-level session management, LiveView on_mount guards |
| Authorization | `SwitchTelemetry.Authorization` | Role-based permission checks via `can?/3` |

## Authentication

### User Schema

Defined in `SwitchTelemetry.Accounts.User`:

```elixir
@primary_key {:id, :string, autogenerate: false}
schema "users" do
  field :email, :string
  field :hashed_password, :string, redact: true
  field :password, :string, virtual: true, redact: true
  field :role, Ecto.Enum, values: [:admin, :operator, :viewer], default: :viewer
  field :confirmed_at, :utc_datetime_usec

  timestamps(type: :utc_datetime_usec)
end
```

Key details:
- UUIDs as string primary keys (generated by the caller, not the database)
- Passwords are hashed with `Bcrypt.hash_pwd_salt/1` and stored in `hashed_password`
- The virtual `:password` field and `:hashed_password` are both marked `redact: true` to prevent leaking into logs or inspect output
- Password validation requires 12-72 characters (`validate_length(:password, min: 12, max: 72)`)
- Email validation: must contain `@`, no spaces, max 160 characters, unique constraint
- `valid_password?/2` calls `Bcrypt.no_user_verify()` when the user is nil to prevent timing-based enumeration attacks

### Session Token Schema

Defined in `SwitchTelemetry.Accounts.UserToken`:

```elixir
schema "user_tokens" do
  field :token, :binary
  field :context, :string
  field :sent_to, :string
  belongs_to :user, SwitchTelemetry.Accounts.User, type: :string

  timestamps(type: :utc_datetime_usec, updated_at: false)
end
```

Token contexts and their validity periods:

| Context | Token Type | Validity | Storage |
|---|---|---|---|
| `"session"` | Raw 32-byte random | 60 days | Raw bytes in DB, raw in session cookie |
| `"magic_link"` | SHA-256 hashed | 1 day | Hash in DB, Base64 in URL |
| `"confirm"` | SHA-256 hashed | 1 day | Hash in DB, Base64 in URL |
| `"reset_password"` | SHA-256 hashed | 1 day | Hash in DB, Base64 in URL |
| `"change:*"` | SHA-256 hashed | 1 day | Hash in DB, Base64 in URL |

Session tokens are stored as raw 32-byte random values (`@rand_size 32`). Email-based tokens are hashed with SHA-256 before storage so that a database leak does not expose usable tokens. The original token is Base64-encoded and sent to the user in a URL.

### Password Login Flow

1. User submits email and password to `POST /users/log_in`
2. `UserSessionController.create/2` calls `Accounts.get_user_by_email_and_password/2`
3. `User.valid_password?/2` verifies the password against the Bcrypt hash
4. On success, `Accounts.maybe_promote_to_admin/1` checks the admin allowlist and upgrades the role if matched
5. `UserAuth.log_in_user/3` creates a session token, renews the session (CSRF fixation prevention), optionally sets a remember-me cookie, and redirects to the stored return-to path or `/dashboards`
6. On failure, a generic "Invalid email or password" error is rendered (prevents user enumeration)

### Remember-Me Cookie

```elixir
@max_age 60 * 60 * 24 * 60  # 60 days
@remember_me_cookie "_switch_telemetry_web_user_remember_me"
@remember_me_options [sign: true, max_age: @max_age, same_site: "Lax", http_only: true]
```

When the user checks "remember me", a signed cookie containing the raw session token is set. On subsequent visits, `fetch_current_user/2` falls back to this cookie if no session token is found in the Plug session.

### Logout

`UserAuth.log_out_user/1`:

1. Deletes the session token from the `user_tokens` table
2. Broadcasts a `"disconnect"` message to the user's LiveView socket (`"users_sessions:<base64_token>"`) so any open LiveView tabs are disconnected
3. Renews the session and clears the session data
4. Deletes the remember-me cookie
5. Redirects to `/users/log_in`

## Magic Link Flow

Magic links provide passwordless login for admin-allowlisted users. The flow:

```
User enters email          Admin allowlist check         Token generated
on login page              (server-side)                 (SHA-256 hashed)
      |                          |                             |
      v                          v                             v
POST /users/magic_link --> Accounts.admin_email?/1 --> get_or_create_user_for_magic_link/1
                                                              |
                                                              v
                           Email with link sent <-- deliver_magic_link_instructions/2
                                                              |
                                                              v
User clicks link ------> GET /users/magic_link/:token
                                |
                                v
                          verify_magic_link_token/1
                                |
                          Deletes all magic_link tokens (single-use)
                                |
                                v
                          maybe_promote_to_admin/1
                                |
                                v
                          UserAuth.log_in_user/2 --> session created --> redirect
```

### Step-by-Step

1. **Request**: User submits their email via `POST /users/magic_link` with `%{"magic_link" => %{"email" => email}}`.

2. **Allowlist check**: `Accounts.admin_email?/1` queries the `admin_emails` table. If the email is not on the allowlist, no token is generated, but the same flash message is shown to prevent enumeration.

3. **Get or create user**: `Accounts.get_or_create_user_for_magic_link/1` returns the existing user or creates a new one with:
   - A random 16-character password (`generate_password/0` uses `:crypto.strong_rand_bytes(12)` + Base64)
   - Role set to `:admin`
   - Automatically confirmed (bypasses email confirmation)
   - The generated password is emailed to the user via `UserNotifier.deliver_generated_password/2`

4. **Token generation**: `deliver_magic_link_instructions/2` builds a hashed email token with context `"magic_link"` and emails the Base64-encoded original to the user. The link is valid for 1 day (`@reset_password_validity_in_days 1`).

5. **Callback**: `GET /users/magic_link/:token` hits `magic_link_callback/2`, which calls `verify_magic_link_token/1`. This decodes the Base64 token, hashes it with SHA-256, queries for a matching row, and deletes all `magic_link` tokens for that user (single-use enforcement).

6. **Session**: On success, `maybe_promote_to_admin/1` runs again, then `UserAuth.log_in_user/2` creates the session and redirects.

### Anti-Enumeration

The controller always shows the same flash message regardless of whether the email was on the allowlist:

```elixir
conn
|> put_flash(:info,
  "If your email is on the admin allowlist, you will receive a sign-in link shortly.")
|> redirect(to: ~p"/users/log_in")
```

## Authorization (RBAC)

Defined in `SwitchTelemetry.Authorization`. Three roles with a default-deny policy:

```elixir
@spec can?(User.t(), action(), resource()) :: boolean()
```

Where:
- `action` is `:view | :create | :edit | :delete`
- `resource` is an atom (e.g., `:device`, `:alert_rule`, `:dashboard`) or a `%Dashboard{}` struct

### Permission Matrix

| Action | Resource | Admin | Operator | Viewer |
|---|---|---|---|---|
| Any | Any | Yes | -- | -- |
| `:view` | Any resource | Yes | Yes | -- |
| `:view` | `:device` | Yes | Yes | Yes |
| `:view` | `:alert` | Yes | Yes | Yes |
| `:view` | `:dashboard_list` | Yes | Yes | Yes |
| `:view` | `%Dashboard{is_public: true}` | Yes | Yes | Yes |
| `:view` | `%Dashboard{created_by: uid}` | Yes | Yes | Yes (own only) |
| `:create` | `:device` | Yes | Yes | No |
| `:edit` | `:device` | Yes | Yes | No |
| `:create` | `:alert_rule` | Yes | Yes | No |
| `:edit` | `:alert_rule` | Yes | Yes | No |
| `:create` | `:dashboard` | Yes | Yes | No |
| `:edit` | `%Dashboard{created_by: uid}` | Yes | Yes (own only) | No |
| `:delete` | `%Dashboard{created_by: uid}` | Yes | Yes (own only) | No |
| `:delete` | (anything else) | Yes | No | No |

Admins bypass all checks via the catch-all clause:

```elixir
def can?(%User{role: :admin}, _action, _resource), do: true
```

Operators can edit/delete only dashboards they created, verified by matching `user.id` against `dashboard.created_by`:

```elixir
def can?(%User{role: :operator, id: uid}, :edit, %Dashboard{created_by: uid})
    when not is_nil(uid),
    do: true
```

The final clause denies everything not explicitly allowed:

```elixir
def can?(_user, _action, _resource), do: false
```

## Admin Email Allowlist

### AdminEmail Schema

Defined in `SwitchTelemetry.Accounts.AdminEmail`:

```elixir
schema "admin_emails" do
  field :email, :string
  timestamps(type: :utc_datetime_usec)
end
```

Validation mirrors the User email rules: required, must contain `@`, no spaces, max 160 characters, unique constraint.

### Management

Admin-only CRUD via `Accounts`:

| Function | Signature | Purpose |
|---|---|---|
| `list_admin_emails/0` | `() -> [AdminEmail.t()]` | List all allowlisted emails, ordered by email |
| `get_admin_email!/1` | `(id) -> AdminEmail.t()` | Fetch by ID, raises on not found |
| `create_admin_email/1` | `(attrs) -> {:ok, t} \| {:error, changeset}` | Add email to allowlist |
| `delete_admin_email/1` | `(admin_email) -> {:ok, t} \| {:error, changeset}` | Remove from allowlist |
| `admin_email?/1` | `(email) -> boolean()` | Check if email is allowlisted |

### Auto-Promotion

`Accounts.maybe_promote_to_admin/1` is called at two points:
1. After successful password login (`UserSessionController.do_create/2`)
2. After successful magic link login (`UserSessionController.magic_link_callback/2`)
3. After user registration (`Accounts.register_user/1`)

Logic:

```elixir
def maybe_promote_to_admin(%User{role: :admin} = user), do: user

def maybe_promote_to_admin(%User{} = user) do
  if admin_email?(user.email) do
    case update_user_role(user, %{role: :admin}) do
      {:ok, updated_user} -> updated_user
      {:error, _} -> user
    end
  else
    user
  end
end
```

If the user is already an admin, it short-circuits. Otherwise, it queries `admin_emails` and promotes if matched. This means an admin can add an email to the allowlist, and the corresponding user will be promoted on their next login.

### Admin UI

Managed via LiveView at `/admin/admin_emails` (requires admin role):

```elixir
live "/admin_emails", AdminEmailLive.Index, :index
live "/admin_emails/new", AdminEmailLive.Index, :new
```

## Plugs

Defined in `SwitchTelemetryWeb.UserAuth` and imported into the router:

### `fetch_current_user/2`

Applied in the `:browser` pipeline to every request. Loads the current user from the session token (or remember-me cookie fallback) and assigns `:current_user` and `:current_path` to the conn.

```elixir
def fetch_current_user(conn, _opts) do
  {user_token, conn} = ensure_user_token(conn)
  user = user_token && Accounts.get_user_by_session_token(user_token)

  conn
  |> assign(:current_user, user)
  |> assign(:current_path, conn.request_path)
end
```

### `redirect_if_user_is_authenticated/2`

Applied to login/registration routes. If the user is already logged in, redirects to `/dashboards` (the `signed_in_path`).

```elixir
def redirect_if_user_is_authenticated(conn, _opts) do
  if conn.assigns[:current_user] do
    conn
    |> redirect(to: signed_in_path(conn))
    |> halt()
  else
    conn
  end
end
```

### `require_authenticated_user/2`

Applied to all protected routes. If no current user, stores the current path for post-login redirect (GET requests only), flashes an error, and redirects to `/users/log_in`.

```elixir
def require_authenticated_user(conn, _opts) do
  if conn.assigns[:current_user] do
    conn
  else
    conn
    |> put_flash(:error, "You must log in to access this page.")
    |> maybe_store_return_to()
    |> redirect(to: ~p"/users/log_in")
    |> halt()
  end
end
```

### `require_admin/2`

Applied to admin routes. Checks `current_user.role == :admin`. Non-admins are redirected to `/` with an error flash.

```elixir
def require_admin(conn, _opts) do
  if conn.assigns[:current_user] && conn.assigns[:current_user].role == :admin do
    conn
  else
    conn
    |> put_flash(:error, "You are not authorized to access this page.")
    |> redirect(to: ~p"/")
    |> halt()
  end
end
```

## LiveView Hooks

Three `on_mount` hooks defined in `SwitchTelemetryWeb.UserAuth`:

### `:mount_current_user`

Assigns `current_user` to the socket using `assign_new/3` so the user is only loaded once per LiveView lifecycle (not re-queried on every mount or navigation).

```elixir
def on_mount(:mount_current_user, _params, session, socket) do
  {:cont, mount_current_user(socket, session)}
end

defp mount_current_user(socket, session) do
  Phoenix.Component.assign_new(socket, :current_user, fn ->
    if user_token = session["user_token"] do
      Accounts.get_user_by_session_token(user_token)
    end
  end)
end
```

### `:ensure_authenticated`

Mounts the current user, then tracks the current path (for navigation highlighting via `attach_hook/4` on `:handle_params`). If no user is found, halts with a redirect to the login page.

```elixir
def on_mount(:ensure_authenticated, _params, session, socket) do
  socket =
    socket
    |> mount_current_user(session)
    |> mount_current_path()

  if socket.assigns.current_user do
    {:cont, socket}
  else
    socket =
      socket
      |> Phoenix.LiveView.put_flash(:error, "You must log in to access this page.")
      |> Phoenix.LiveView.redirect(to: ~p"/users/log_in")
    {:halt, socket}
  end
end
```

### `:ensure_admin`

Same as `:ensure_authenticated`, but additionally checks `current_user.role == :admin`. Non-admins are redirected to `/` with an authorization error.

```elixir
def on_mount(:ensure_admin, _params, session, socket) do
  socket =
    socket
    |> mount_current_user(session)
    |> mount_current_path()

  if socket.assigns.current_user && socket.assigns.current_user.role == :admin do
    {:cont, socket}
  else
    socket =
      socket
      |> Phoenix.LiveView.put_flash(:error, "You are not authorized to access this page.")
      |> Phoenix.LiveView.redirect(to: ~p"/")
    {:halt, socket}
  end
end
```

## Encryption at Rest

### Cloak Vault

`SwitchTelemetry.Vault` uses the `Cloak.Vault` behaviour:

```elixir
defmodule SwitchTelemetry.Vault do
  use Cloak.Vault, otp_app: :switch_telemetry
end
```

Configuration (in `config.exs` for dev, `runtime.exs` for prod):

```elixir
config :switch_telemetry, SwitchTelemetry.Vault,
  ciphers: [
    default: {Cloak.Ciphers.AES.GCM, tag: "AES.GCM.V1", key: Base.decode64!(cloak_key)}
  ]
```

In production, the key is read from the `CLOAK_KEY` environment variable. The `tag: "AES.GCM.V1"` prefix on each ciphertext enables key rotation -- new ciphers can be added with a different tag, and old data can be re-encrypted in a migration.

### Encrypted Ecto Type

```elixir
defmodule SwitchTelemetry.Encrypted.Binary do
  use Cloak.Ecto.Binary, vault: SwitchTelemetry.Vault
end
```

This custom Ecto type transparently encrypts data before writing to PostgreSQL and decrypts on read.

### Encrypted Fields

The `SwitchTelemetry.Devices.Credential` schema uses `SwitchTelemetry.Encrypted.Binary` for all sensitive device credential fields:

```elixir
@derive {Inspect, except: [:password, :ssh_key, :tls_key]}
schema "credentials" do
  field :name, :string
  field :username, :string
  field :password, SwitchTelemetry.Encrypted.Binary
  field :ssh_key, SwitchTelemetry.Encrypted.Binary
  field :tls_cert, SwitchTelemetry.Encrypted.Binary
  field :tls_key, SwitchTelemetry.Encrypted.Binary

  has_many :devices, SwitchTelemetry.Devices.Device
  timestamps(type: :utc_datetime_usec)
end
```

Four fields are encrypted: `password`, `ssh_key`, `tls_cert`, and `tls_key`. Additionally, `@derive {Inspect, except: [:password, :ssh_key, :tls_key]}` prevents these fields from appearing in `IO.inspect/2` or logger output. Note that `tls_cert` is excluded from the `@derive` list since certificates are considered public, but it is still encrypted at rest.

## Security Headers

### Content Security Policy (CSP)

Configured in the router's `:browser` pipeline via `put_secure_browser_headers/2`:

```elixir
plug :put_secure_browser_headers, %{
  "content-security-policy" =>
    "default-src 'self'; " <>
      "script-src 'self' 'unsafe-eval'; " <>
      "style-src 'self' 'unsafe-inline'; " <>
      "img-src 'self' data: blob:; " <>
      "font-src 'self' data:; " <>
      "connect-src 'self' wss: ws:; " <>
      "frame-ancestors 'none'"
}
```

| Directive | Value | Rationale |
|---|---|---|
| `default-src` | `'self'` | Only load resources from the same origin |
| `script-src` | `'self' 'unsafe-eval'` | Same origin + eval (required by Vega-Lite runtime) |
| `style-src` | `'self' 'unsafe-inline'` | Same origin + inline styles (required by Tailwind/Vega) |
| `img-src` | `'self' data: blob:` | Same origin + data URIs + blob URLs (Vega chart exports) |
| `font-src` | `'self' data:` | Same origin + data URI fonts |
| `connect-src` | `'self' wss: ws:` | Same origin + WebSocket connections (LiveView) |
| `frame-ancestors` | `'none'` | Prevents embedding in iframes (clickjacking protection) |

`put_secure_browser_headers/2` also sets `x-frame-options: SAMEORIGIN`, `x-content-type-options: nosniff`, and `x-xss-protection: 1; mode=block` by default.

### HSTS

Enabled in production via `force_ssl` in `config/runtime.exs`:

```elixir
config :switch_telemetry, SwitchTelemetryWeb.Endpoint,
  url: [host: host, port: 443, scheme: "https"],
  http: [ip: {0, 0, 0, 0, 0, 0, 0, 0}, port: port],
  secret_key_base: secret_key_base,
  force_ssl: [hsts: true, rewrite_on: [:x_forwarded_proto]]
```

This enables:
- HSTS header on all responses (`Strict-Transport-Security: max-age=31536000`)
- Automatic HTTP-to-HTTPS redirect
- `rewrite_on: [:x_forwarded_proto]` trusts the `X-Forwarded-Proto` header from reverse proxies (load balancers)

### CSRF Protection

The `:browser` pipeline includes `plug :protect_from_forgery`, which uses Phoenix's built-in CSRF token validation for all non-GET requests. LiveView passes `_csrf_token` via socket params.

### Parameter Filtering

Configured in `config/config.exs` to redact sensitive values from Phoenix request logs:

```elixir
config :phoenix, :filter_parameters, [
  "password",
  "secret",
  "token",
  "ssh_key",
  "tls_key",
  "tls_cert",
  "current_password",
  "api_key",
  "cloak_key"
]
```

## Router Security

### Pipeline Structure

The router defines two pipelines:

| Pipeline | Purpose |
|---|---|
| `:browser` | HTML requests: session, CSRF, CSP headers, `fetch_current_user` |
| `:api` | JSON requests: accepts JSON only |

### Scope-Based Auth Enforcement

Four route scopes with increasing auth requirements:

**1. Unauthenticated (redirects away if logged in)**

```
pipe_through [:browser, :redirect_if_user_is_authenticated]
```

| Method | Path | Controller |
|---|---|---|
| `GET` | `/users/log_in` | `UserSessionController :new` |
| `POST` | `/users/log_in` | `UserSessionController :create` |
| `POST` | `/users/magic_link` | `UserSessionController :create_magic_link` |
| `GET` | `/users/magic_link/:token` | `UserSessionController :magic_link_callback` |

**2. Authenticated (non-LiveView)**

```
pipe_through [:browser, :require_authenticated_user]
```

| Method | Path | Controller |
|---|---|---|
| `DELETE` | `/users/log_out` | `UserSessionController :delete` |

**3. Authenticated LiveViews**

```elixir
live_session :authenticated,
  on_mount: [{SwitchTelemetryWeb.UserAuth, :ensure_authenticated}] do
  pipe_through [:browser, :require_authenticated_user]
  ...
end
```

Double protection: the `require_authenticated_user` plug guards the initial HTTP request, and the `:ensure_authenticated` on_mount hook guards the WebSocket connection. Routes include:

- `/dashboards` -- Dashboard CRUD and widget management
- `/devices` -- Device inventory and subscriptions
- `/credentials` -- Credential management
- `/streams` -- Live stream monitoring
- `/alerts` -- Alert rules and channels
- `/settings` -- User settings

**4. Admin LiveViews**

```elixir
live_session :admin,
  on_mount: [{SwitchTelemetryWeb.UserAuth, :ensure_admin}] do
  pipe_through [:browser, :require_authenticated_user, :require_admin]
  ...
end
```

Triple protection: `require_authenticated_user` plug + `require_admin` plug + `:ensure_admin` on_mount hook. Routes:

| Path | LiveView | Purpose |
|---|---|---|
| `/admin/users` | `UserLive.Index` | User management |
| `/admin/admin_emails` | `AdminEmailLive.Index` | Admin allowlist management |
| `/admin/admin_emails/new` | `AdminEmailLive.Index :new` | Add email to allowlist |

**5. Public**

```
pipe_through :browser
```

| Method | Path | Controller |
|---|---|---|
| `GET` | `/` | `PageController :home` |

### Session Management

The `log_in_user/3` function performs session fixation prevention by calling `renew_session/1`:

```elixir
defp renew_session(conn) do
  Plug.CSRFProtection.delete_csrf_token()

  conn
  |> configure_session(renew: true)
  |> clear_session()
end
```

This deletes the CSRF token, generates a new session ID, and clears all session data before writing the new session token. The `live_socket_id` is derived from the token (`"users_sessions:<base64_token>"`) to enable targeted LiveView disconnection on logout.
